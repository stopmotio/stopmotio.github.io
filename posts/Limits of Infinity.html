<p><i>May 17, 2022</i></p>

<p>There is always a limit, no matter how large, on the size of any number in a computer. The TI-84 family of calculators appear to give an overflow error if, inside scientific notation, the number ends in <code>e100</code>. However, it can only store integers up to 14 digits long, so it will always round numbers this large. The hard limit is there to avoid some of the issues with extremely large numbers in floating point operations. As you approach the integer limit, the computer basically runs out of digits. In more basic integer functions, the fun stops here.</p>

<p>First, a brief introduction in binary numbers. Humans use a base-10 system, because once you hit 10, you can no longer store that in a single digit. However, since binary is either on or off, we have two states. So, we limit ourselves to 0 and 1, and use a new digit for 2 and beyond. This is called a base-2 system. From here, we need to work out where our first whole number is. The easiest way to do this is integers, since they do not have decimals. Of course, in a 32-bit system, you get 32 digits and nothing more. So what happens when you need a 33rd digit? Usually this should not be allowed to happen at all, and even if it is, the math should just fail. If the stars align, though, the operation could cause the CPU to write into a next byte. This is called a buffer overflow, and it corrupts whatever data was present in that byte. Bytes are incredibly small, but this is usually in RAM, which cannot really be audited for errors without reducing performace. So, the data corrupts, and what happens afterward depends on what that byte was, and is highly unpredicatable. This is a <em>massive</em> oversimplification, and I am skipping over loads of stuff, like signed integers.</p>

<p>Floating point numbers are different. They are able to store decimals by moving the decimal point around, including out of the bounds of the number, allowing it to store rounded versions of very large or small numbers. Basically, it allows for decimals operations, and can act like scientific notation. So, when it exits what is allowable in an integer, it begins rounding. This is where the fun begins. As it begins rounding more and more, it loses precision. A good example of floating point numbers in action is Minecraft. Minecraft's unit is the block, so each block is one whole number, and it uses decimals for values in between this, such as the location of mobs within that distance and to draw most things, since each vertex needs to be representable as a precise number to draw accurately. In Java Edition, these issues created the Farlands, but has since been fixed, and now, it is not possible to travel beyond 30 million blocks away from spawn, to avoid these issues. Bedrock Edition, however, still has no limit. You cannot teleport past 30 million blocks, but you can travel well beyond that, and before even 30 million blocks out, the game begins to lose precision and blocks such as fences, sunflowers, and anything that isn't just the basic block shape get noticably distorted. Feel free to try this out in game; It's super interesting and you won't regret it.</p>

<p><i>Everything on this page is a massive oversimplification and does not cover the full story. Numbers are surprisingly complicated and I am not an expert. Don't take this too seriously.</i></p>
